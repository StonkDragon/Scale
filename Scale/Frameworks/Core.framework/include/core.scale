using "io" from "Core"
using "util/array" from "Core"

function sleep(_millis_: int): none
  start_c
    sleep(*_millis_);
  end_c
end

function system(_cmd_: str): int
  decl ret: int
  start_c
    *ret = system(*_cmd_);
  end_c
  ret return
end

function getenv(_key_: str): str
  decl v: str
  start_c
    *v = getenv(*_key_);
  end_c
  v return
end

function sizeof_stack(): int
  start_c
    stack.data[stack.ptr++].i = stack.ptr;
  end_c
  return
end

function malloc(_size_: int): [any]
  decl s: [any]
  start_c
    *s = scl_alloc(*_size_);
    if (!(*s)) {
      scl_security_throw(EX_BAD_PTR, "malloc() failed!");
      *s = NULL;
    }
  end_c
  s return
end

function realloc(_size_: int, _ptr_: [any]): [any]
  start_c
    *_ptr_ = scl_realloc(*_ptr_, *_size_);
    if (!(*_ptr_)) {
      scl_security_throw(EX_BAD_PTR, "realloc() failed!");
      *_ptr_ = NULL;
    }
  end_c
  _ptr_ return
end

function free(_ptr_: [any]): none
  start_c
    scl_free(*_ptr_);
  end_c
end

function strlen(_str_: str): int
  0 => decl len: int
  while _str_ len + @ 0 != do
    len 1 + => len
  done
  len return
end

function strsplit(_str_: str, _delim_: str): Array
  10 Array::new => decl arr: Array
  start_c
    scl_str string = strdup(*_str_);
    scl_str line = strtok(string, *_delim_);
    while (line != NULL) {
      Method_Array_push(*arr, line);
      line = strtok(NULL, *_delim_);
    }
  end_c
  arr return
end

function strcmp(_str1_: str, _str2_: str): int
  decl t: bool
  start_c
    *t = strcmp(*_str1_, *_str2_) == 0;
  end_c
  t return
end

function strdup(_str_: str): str
  decl s: str
  start_c
    *s = strdup(*_str_);
  end_c
  s return
end

function strncmp(_str1_: str, _str2_: str, _n_: int): int
  decl t: bool
  start_c
    *t = strncmp(*_str1_, *_str2_, *_n_) == 0;
  end_c
  t return
end

function concat(_str1_: str, _str2_: str): str
  decl out: str
  _str1_ strlen => decl len: int
  _str2_ strlen => decl len2: int

  len len2 + 1 + malloc => out

  out _str1_ strcpy
  start_c
    strcat(*out, *_str2_);
  end_c

  out return
end

function strcpy(dest: str, src: str): none
  start_c
    strcpy(*dest, *src);
  end_c
  dest drop
end

function strrev(_str_: str): str
  decl out: str
  start_c
    scl_int i = 0;
    scl_int len = strlen(*_str_);
    *out = scl_alloc(len + 1);
    for (i = len - 1; i >= 0; i--) {
      (*out)[i] = (*_str_)[len - i - 1];
    }
    (*out)[len] = '\0';
  end_c
  out return
end

function time(): float
  decl secs: float
  start_c
    struct timeval tv;
    gettimeofday(&tv, NULL);
    *secs = (double)(tv.tv_usec) / 1000000 + (double)(tv.tv_sec);
  end_c
  secs return
end

function longToString(_long_: int): str
  decl out: str
  start_c
    *out = scl_alloc(25);
	  sprintf(*out, "%lld", *_long_);
  end_c
  out return
end

function stringToLong(_str_: str): int
  start_c
    stack.data[stack.ptr++].i = atoll(*_str_);
  end_c
  return
end

function stringToDouble(_str_: str): float
  start_c
    stack.data[stack.ptr++].f = atof(*_str_);
  end_c
  return
end

function doubleToString(_double_: float): str
  decl out: str
  start_c
    *out = scl_alloc(100);
	  sprintf(*out, "%f", *_double_);
  end_c
  out return
end

function nop(): none
  0 sleep
end

function strstarts(_s1_: str, _s2_: str): bool
  _s2_ strlen _s2_ _s1_ strncmp return
end

function sizeof(_type_: str): int
  _type_ "int" strcmp if
    8 return
  fi
  _type_ "float" strcmp if
    8 return
  fi
  _type_ "none" strcmp if
    0 return
  fi
  _type_ "str" strcmp if
    8 return
  fi
  _type_ "any" strcmp if
    8 return
  fi
  -1 return
end

function toChar(_val_: int): int
  _val_ 0xff & return
end

function toInt(_val_: int): int
  _val_ 0xffffffff & return
end

function toShort(_val_: int): int
  _val_ 0xffff & return
end

function toChars(_str_: str): Array
  # decl _len_: int _str_ strlen => _len_
  decl _arr_: Array _str_ strlen Array::new => _arr_

  for _i_ in 0 to _str_ strlen do
    _str_ _i_ + @ toChar _arr_:push
  done
  _arr_ return 0
end
