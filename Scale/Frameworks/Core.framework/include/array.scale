#ifndef ARRAY_H
#define ARRAY_H

extern function trace()

struct Array
  decl values
  decl count
  decl capacity
end

extern function arraySort(array) -> Array

function arrayGet(arr, index) -> any
  arr::Array.values {index} @ return
end

function arraySet(arr, index, value) -> none
  decl tmp
  arr::Array.values index 3 << + store tmp
  value store @tmp
end

function arrayTop(arr) -> any
  arr::Array.values arr::Array.count 1 - 3 << + @ return
end

function arrayPush(arr, value) -> none
  arr::Array.count arr::Array.capacity >= if
    arr::Array.capacity 2 * store arr::Array.capacity
    arr::Array.values arr::Array.capacity 8 * realloc
    store arr::Array.values
  fi

  decl tmp
  arr::Array.values arr::Array.count 3 << + store tmp
  value store @tmp
  arr::Array.count 1 + store arr::Array.count
end

function arrayPop(arr) -> none
  arr::Array.count 1 - store arr::Array.count
end

function arrayCreate(initialSize) -> Array
  initialSize 1 < if
    "Invalid Argument: initialSize must not be 0 or less\n" puts trace 1 exit
  fi

  decl arr
  new Array store arr
  initialSize 8 * malloc
  store arr::Array.values
  initialSize store arr::Array.count
  initialSize store arr::Array.capacity
  arr return
end

#endif
