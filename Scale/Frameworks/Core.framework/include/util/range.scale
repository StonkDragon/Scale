using "util/iterable" from "Core"

@sealed
struct Range is Iterable
  decl _start: int
  decl _end: int
  decl _pos: int

  function init(_start: int, _end: int): none
    _start _end > if
      "start must not be bigger than end! Use ReverseRange if you want that" eputs trace 1 exit
    fi

    _start => self._start
    _end => self._end
    0 => self._pos
  end

  function containsRange(other: Range): int
    other._start self:contains other._end self:contains && if
      true return
    fi
    false return
  end

  function overlaps(other: Range): int
    other._start self:contains other._end self:contains || if
      true return
    fi
    false return
  end

  function contains(pos: int): int
    pos self._start >= if
      pos self._end <= if
        true return
      fi
    fi
    false return
  end

  function has_next(): bool
    self._pos self._start + self._end <= return
  end

  function next(): int
    self._pos 1 + => self._pos
    self._start self._pos + return
  end

  function begin(): int
    0 => self._pos
    self._start return
  end

  function toReverseRange(): ReverseRange
    self._end self._start ReverseRange:new return
  end
end

@sealed
struct ReverseRange is Iterable
  decl _start: int
  decl _end: int
  decl _pos: int

  function init(_start: int, _end: int): none
    _start _end < if
      "end must not be bigger than start! Use Range if you want that" eputs trace 1 exit
    fi
      
    _start => self._start
    _end => self._end
    0 => self._pos
  end

  function has_next(): bool
    self._start self._pos - self._end >= return
  end

  function next(): int
    self._pos 1 + => self._pos
    self._start self._pos - return
  end

  function begin(): int
    0 => self._pos
    self._start return
  end

  function toRange(): Range
    self._end self._start Range:new return
  end
end
