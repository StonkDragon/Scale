extern function trace(): none

struct Array
  decl values: any
  decl count: int
  decl capacity: int
end

extern function Array:sort(): none

function Array:get(index: int): any
  self.values index 3 << + @ return
end

function Array:set(index: int, value: any): none
  decl tmp: any
  self.values index 3 << + => tmp
  value => @tmp
end

function Array:top(): any
  self.values self.count 1 - 3 << + @ return
end

function Array:push(value: any): none
  self.count self.capacity >= if
    self.capacity 2 * => self.capacity
    self.capacity 8 * self.values realloc
    => self.values
  fi

  decl tmp: any
  self.values self.count 3 << + => tmp
  value => @tmp
  self.count 1 + => self.count
end

function Array:pop(): none
  self.count 1 - => self.count
end

function Array:init(size: int): none
  size 1 < if
    "Invalid Argument: size must not be 0 or less\n" eputs trace 1 exit
  fi
  size 8 * malloc
  => self.values
  0 => self.count
  size => self.capacity
end

struct ArrayIterator
    decl array: Array
    decl pos: int
end

function ArrayIterator:has_next(): int
    self.pos self.array Array.count < return
end

function ArrayIterator:next(): any
    self.pos 1 + => self.pos
    self.pos self.array Array:get return
end

function ArrayIterator:begin(): any
    self.pos self.array Array:get return
end

function ArrayIterator:init(arr: Array): none
    arr => self.array
    0 => self.pos
end

