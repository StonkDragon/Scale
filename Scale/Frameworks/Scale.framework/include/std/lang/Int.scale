cdecl "atoll"
private expect foreign unsafe function __c_atoll(:[int8]): int64
cdecl "snprintf"
private expect foreign unsafe function __c_snprintf(:[int8], :int, :[int8], :varargs): int
cdecl "printf"
private expect foreign unsafe function __c_printf(:[int8], :varargs): int

macro! IntStruct(type) {
  final static struct $type
    (
      1 sizeof $type 8 * 1 - <<
    ) => decl minValue: const $type
    (
      if sizeof $type 8 == then
        0x7fffffffffffffff
      else
        1 sizeof $type 8 * 1 - << 1 -
      fi
    ) => decl maxValue: const $type

    function toString(x: $type): str
      new<int8>[32] => decl out: [int8]
      unsafe
        if sizeof $type 1 == then
          out 31 c"%c" varargs x __c_snprintf drop
        else
          out 31 c"%ld" varargs x __c_snprintf drop
        fi
      end
      out:resizeToFit str::new return
    end

    function toHexString(x: $type): str
      new<int8>[32] => decl out: [int8]
      unsafe
        out 31 "0x%0" sizeof $type 2 * + "lx" +:view varargs x __c_snprintf drop
      end
      out:resizeToFit str::new return
    end

    function parse(s: str): $type
      unsafe
        s:view __c_atoll as $type return
      end
    end

    function asReference(i: $type): Box<$type>
      Box<$type> {
        i => value
      } return
    end

    function =>(x: float): $type
      x as $type return
    end

    function =>(x: float32): $type
      x as $type return
    end
  end
}
macro! UIntStruct(type) {
  final static struct $type
    (0) => decl minValue: const $type
    (-1) => decl maxValue: const $type

    function toString(x: $type): str
      new<int8>[32] => decl out: [int8]
      unsafe
        if sizeof $type 1 == then
          out 31 c"%c" varargs x __c_snprintf drop
        else
          out 31 c"%lu" varargs x __c_snprintf drop
        fi
      end
      out:resizeToFit str::new return
    end

    function toHexString(x: $type): str
      new<int8>[32] => decl out: [int8]
      unsafe
        out 31 "0x%0" sizeof $type 2 * + "lx" +:view varargs x __c_snprintf drop
      end
      out:resizeToFit str::new return
    end

    function parse(s: str): $type
      unsafe
        s:view __c_atoll as $type return
      end
    end

    function asReference(i: $type): Box<$type>
      Box<$type> {
        i => value
      } return
    end

    function =>(x: float): $type
      x as $type return
    end

    function =>(x: float32): $type
      x as $type return
    end
  end
}

final static struct bool
  function toString(x: bool): str
    if x then
      "true" return
    else
      "false" return
    fi
  end

  function parse(s: str): bool
    if s "true" == then
      true return
    elif s "false" == then
      false return
    fi
    unsafe
      s:view __c_atoll 0 != return
    end
  end

  function asReference(i: bool): Box<bool>
    Box<bool> {
      i => value
    } return
  end
end

IntStruct! int8
IntStruct! int16
IntStruct! int32
IntStruct! int64
IntStruct! int
UIntStruct! uint8
UIntStruct! uint16
UIntStruct! uint32
UIntStruct! uint64
UIntStruct! uint

reified operator "add" function +<A, B>(:A, :B): _ABBigger
reified operator "sub" function -<A, B>(:A, :B): _ABBigger
reified operator "mul" function *<A, B>(:A, :B): _ABBigger
reified operator "div" function /<A, B>(:A, :B): _ABBigger
reified operator "pow" function **<A, B>(:A, :B): _ABBigger

reified function /.<A>(:A, :A): A gcd end
reified function *.<A>(:A, :A): A lcm end
reified function >.<A>(:A, :A): A max end
reified function <.<A>(:A, :A): A min end

expect reified operator "eq" function == <A?, B?>(:A?, :B?): bool
expect reified operator "ne" function != <A?, B?>(:A?, :B?): bool
expect reified operator "gt" function > <A?, B?>(:A?, :B?): bool
expect reified operator "ge" function >= <A?, B?>(:A?, :B?): bool
expect reified operator "lt" function < <A?, B?>(:A?, :B?): bool
expect reified operator "le" function <= <A?, B?>(:A?, :B?): bool

expect operator "and" function &&(:int, :int): bool
expect operator "or" function ||(:int, :int): bool
expect operator "not" function !(:int): bool

expect reified operator "mod" function % <A, >(:A, :int): A
expect reified operator "land" function & <A, >(:A, :int): A
expect reified operator "lor" function | <A, >(:A, :int): A
expect reified operator "lxor" function ^ <A, >(:A, :int): A
expect reified operator "lnot" function ~ <A>(:A): A
expect reified operator "lsl" function << <A, >(:A, :int): A
expect reified operator "lsr" function >> <A, >(:A, :int): A
expect reified operator "rol" function <<< <A, >(:A, :int): A
expect reified operator "ror" function >>> <A, >(:A, :int): A

expect reified operator "inc" function ++ <A>(:A): A
expect reified operator "dec" function -- <A>(:A): A

expect reified operator "at" function @<*T>(:*T): T
expect reified operator "ann" function !!<T?>(:T?): T
expect reified operator "elvis" function ?:<T?, >(:T?, :T): T

function isnil(x: any): bool
  x nil == return
end

function isnotnil(x: any): bool
  x nil != return
end
