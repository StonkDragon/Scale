cdecl "atoll"
private expect foreign unsafe function __c_atoll(:[int8]): int64
cdecl "sprintf"
private expect foreign unsafe function __c_sprintf(:[int8], :[int8], :varargs): int
cdecl "printf"
private expect foreign unsafe function __c_printf(:[int8], :varargs): int

macro! IntStruct(type) {
  final static struct $type
    (
      1 sizeof $type 8 * 1 - <<
    ) => decl minValue: const $type
    (
      if sizeof $type 8 == then
        0x7fffffffffffffff
      else
        1 sizeof $type 8 * 1 - << 1 -
      fi
    ) => decl maxValue: const $type

    function toString(x: $type): str
      new<int8>[32] => decl out: [int8]
      unsafe
        if sizeof $type 1 == then
          out c"%c" varargs x __c_sprintf drop
        else
          out c"%ld" varargs x __c_sprintf drop
        fi
      end
      out:resizeToFit str::new return
    end

    function toHexString(x: $type): str
      new<int8>[32] => decl out: [int8]
      unsafe
        out "0x%0" sizeof $type 2 * + "lx" +:view varargs x __c_sprintf drop
      end
      out:resizeToFit str::new return
    end

    function parse(s: str): $type
      unsafe
        s:view __c_atoll as $type return
      end
    end

    function asReference(i: int): Int
      i Int::new return
    end

    function =>(x: float): $type
      x as $type return
    end

    function =>(x: float32): $type
      x as $type return
    end
  end
}
macro! UIntStruct(type) {
  final static struct $type
    (0) => decl minValue: const $type
    (-1) => decl maxValue: const $type

    function toString(x: $type): str
      new<int8>[32] => decl out: [int8]
      unsafe
        if sizeof $type 1 == then
          out c"%c" varargs x __c_sprintf drop
        else
          out c"%lu" varargs x __c_sprintf drop
        fi
      end
      out:resizeToFit str::new return
    end

    function toHexString(x: $type): str
      new<int8>[32] => decl out: [int8]
      unsafe
        out "0x%0" sizeof $type 2 * + "lx" +:view varargs x __c_sprintf drop
      end
      out:resizeToFit str::new return
    end

    function parse(s: str): $type
      unsafe
        s:view __c_atoll as $type return
      end
    end

    function asReference(i: int): Int
      i Int::new return
    end

    function =>(x: float): $type
      x as $type return
    end

    function =>(x: float32): $type
      x as $type return
    end
  end
}

final static struct bool
  function toString(x: bool): str
    if x then
      "true" return
    else
      "false" return
    fi
  end

  function parse(s: str): bool
    if s "true" == then
      true return
    elif s "false" == then
      false return
    fi
    unsafe
      s:view __c_atoll 0 != return
    end
  end
end

IntStruct! int8
IntStruct! int16
IntStruct! int32
IntStruct! int64
IntStruct! int
UIntStruct! uint8
UIntStruct! uint16
UIntStruct! uint32
UIntStruct! uint64
UIntStruct! uint

delmacro! IntStruct
delmacro! UIntStruct

final struct Int
  decl value: readonly int

  static function valueOf(x: int): Int
    x Int::new return
  end

  init(x: int)
    x => self.value
  end

  function equals(other: any): bool
    if other is Int then
      other as Int.value self.value == return
    else
      other as int self.value == return
    fi
  end

  function ==(other: any): bool
    other self:equals return
  end

  function !=(other: any): bool
    other self:equals ! return
  end

  function @(): int
    self.value return
  end

  const function toString(): str
    self.value:toString return
  end
end

reified operator "add" function +<A, B>(:A, :B): _ABBigger
reified operator "sub" function -<A, B>(:A, :B): _ABBigger
reified operator "mul" function *<A, B>(:A, :B): _ABBigger
reified operator "div" function /<A, B>(:A, :B): _ABBigger
reified operator "pow" function **<A, B>(:A, :B): _ABBigger

reified function /.<A, >(:A, :A): A gcd end
reified function *.<A, >(:A, :A): A lcm end
reified function >.<A, >(:A, :A): A max end
reified function <.<A, >(:A, :A): A min end

expect reified operator "eq" function == <A?, B?>(:A?, :B?): bool
expect reified operator "ne" function != <A?, B?>(:A?, :B?): bool
expect reified operator "gt" function > <A?, B?>(:A?, :B?): bool
expect reified operator "ge" function >= <A?, B?>(:A?, :B?): bool
expect reified operator "lt" function < <A?, B?>(:A?, :B?): bool
expect reified operator "le" function <= <A?, B?>(:A?, :B?): bool

expect operator "and" function &&(:int, :int): bool
expect operator "or" function ||(:int, :int): bool
expect operator "not" function !(:int): bool

expect reified operator "mod" function % <A, >(:A, :int): A
expect reified operator "land" function & <A, >(:A, :int): A
expect reified operator "lor" function | <A, >(:A, :int): A
expect reified operator "lxor" function ^ <A, >(:A, :int): A
expect reified operator "lnot" function ~ <A>(:A): A
expect reified operator "lsl" function << <A, >(:A, :int): A
expect reified operator "lsr" function >> <A, >(:A, :int): A
expect reified operator "rol" function <<< <A, >(:A, :int): A
expect reified operator "ror" function >>> <A, >(:A, :int): A

expect reified operator "inc" function ++ <A>(:A): A
expect reified operator "dec" function -- <A>(:A): A

expect reified operator "at" function @<[T]>(:[T]): T
expect reified operator "ann" function !!<T?>(:T?): T
expect reified operator "elvis" function ?:<T?, >(:T?, :T): T

function isnil(x: any): bool
  x nil == return
end

function isnotnil(x: any): bool
  x nil != return
end
