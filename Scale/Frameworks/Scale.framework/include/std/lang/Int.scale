cdecl "atoll"
private expect foreign unsafe function __c_atoll(:[int8]): int64
cdecl "snprintf"
private expect foreign unsafe function __c_snprintf(:[int8], :int, :[int8], :varargs): int
cdecl "printf"
private expect foreign unsafe function __c_printf(:[int8], :varargs): int

macro! IntStruct(type) {
  final static struct $type
    (1u sizeof $type 8 * 1 - <<     as $type) => decl minValue: const $type
    (1u sizeof $type 8 * 1 - << 1 - as $type) => decl maxValue: const $type

    function toString(x: $type): str
      new<int8>[32] => decl out: [int8]
      unsafe
        out 31 c"%ld" varargs x __c_snprintf drop
      end
      out:resizeToFit str::new return
    end

    function toHexString(x: $type): str
      new<int8>[32] => decl out: [int8]
      unsafe
        sizeof $type switch
          case 1 out 31 c"0x%02lx"  varargs x __c_snprintf drop esac
          case 2 out 31 c"0x%04lx"  varargs x __c_snprintf drop esac
          case 4 out 31 c"0x%08lx"  varargs x __c_snprintf drop esac
          case 8 out 31 c"0x%016lx" varargs x __c_snprintf drop esac
        done
      end
      out:resizeToFit str::new return
    end

    function parse(s: str): $type
      unsafe
        s:view __c_atoll as $type return
      end
    end

    function asReference(i: $type): Box<$type>
      Box<$type> {
        i => value
      } return
    end

    function =>(x: float): $type
      x as $type return
    end

    function =>(x: float32): $type
      x as $type return
    end
  end
}
macro! UIntStruct(type) {
  final static struct $type
    (0  as $type) => decl minValue: const $type
    (-1 as $type) => decl maxValue: const $type

    function toString(x: $type): str
      new<int8>[32] => decl out: [int8]
      unsafe
        out 31 c"%lu" varargs x __c_snprintf drop
      end
      out:resizeToFit str::new return
    end

    function toHexString(x: $type): str
      new<int8>[32] => decl out: [int8]
      unsafe
        sizeof $type switch
          case 1 out 31 c"0x%02lx"  varargs x __c_snprintf drop esac
          case 2 out 31 c"0x%04lx"  varargs x __c_snprintf drop esac
          case 4 out 31 c"0x%08lx"  varargs x __c_snprintf drop esac
          case 8 out 31 c"0x%016lx" varargs x __c_snprintf drop esac
        done
      end
      out:resizeToFit str::new return
    end

    function parse(s: str): $type
      unsafe
        s:view __c_atoll as $type return
      end
    end

    function asReference(i: $type): Box<$type>
      Box<$type> {
        i => value
      } return
    end

    function =>(x: float): $type
      x as $type return
    end

    function =>(x: float32): $type
      x as $type return
    end
  end
}

final static struct bool
  function toString(x: bool): str
    if x then
      "true" return
    else
      "false" return
    fi
  end

  function parse(s: str): bool
    if s "true" == then
      true return
    elif s "false" == then
      false return
    fi
    unsafe
      s:view __c_atoll 0 != return
    end
  end

  function asReference(i: bool): Box<bool>
    Box<bool> {
      i => value
    } return
  end
end

final static struct Char
  function toString(x: int8): str
    new<int8> {
      x,
      0
    } str::new return
  end

  function parse(s: str): int8
    s[0] return
  end
end

IntStruct! int8
IntStruct! int16
IntStruct! int32
IntStruct! int64
IntStruct! int
UIntStruct! uint8
UIntStruct! uint16
UIntStruct! uint32
UIntStruct! uint64
UIntStruct! uint

reified @NumericOperator operator "add" function +  <Lhs, Rhs>(:Lhs, :Rhs): Numeric
reified @NumericOperator operator "sub" function -  <Lhs, Rhs>(:Lhs, :Rhs): Numeric
reified @NumericOperator operator "mul" function *  <Lhs, Rhs>(:Lhs, :Rhs): Numeric
reified @NumericOperator operator "div" function /  <Lhs, Rhs>(:Lhs, :Rhs): Numeric
reified @NumericOperator operator "pow" function ** <Lhs, Rhs>(:Lhs, :Rhs): Numeric

reified function /. <A>(:A, :A): A gcd end
reified function *. <A>(:A, :A): A lcm end
reified function >. <A>(:A, :A): A max end
reified function <. <A>(:A, :A): A min end

expect reified operator "eq" function == <A?, B?>(:A?, :B?): bool
expect reified operator "ne" function != <A?, B?>(:A?, :B?): bool
expect reified operator "gt" function >  <A?, B?>(:A?, :B?): bool
expect reified operator "ge" function >= <A?, B?>(:A?, :B?): bool
expect reified operator "lt" function <  <A?, B?>(:A?, :B?): bool
expect reified operator "le" function <= <A?, B?>(:A?, :B?): bool

expect operator "and" function &&(:int, :int): bool
expect operator "or"  function ||(:int, :int): bool
expect operator "not" function !(:int): bool

expect reified operator "mod"  function %   <A, >(:A, :int): A
expect reified operator "land" function &   <A, >(:A, :int): A
expect reified operator "lor"  function |   <A, >(:A, :int): A
expect reified operator "lxor" function ^   <A, >(:A, :int): A
expect reified operator "lnot" function ~   <A>(:A): A
expect reified operator "lsl"  function <<  <A, >(:A, :int): A
expect reified operator "lsr"  function >>  <A, >(:A, :int): A
expect reified operator "rol"  function <<< <A, >(:A, :int): A
expect reified operator "ror"  function >>> <A, >(:A, :int): A

expect reified operator "inc" function ++ <A>(:A): A
expect reified operator "dec" function -- <A>(:A): A

expect unsafe reified operator "at"    function @  <*T>(:*T): T
expect        reified operator "ann"   function !! <T?>(:T?): T
expect        reified operator "elvis" function ?: <T?, >(:T?, :T): T

function isnil(x: any): bool
  x nil == return
end

function isnotnil(x: any): bool
  x nil != return
end
