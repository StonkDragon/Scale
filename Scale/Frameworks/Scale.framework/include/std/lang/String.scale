import std.util.Stringifyable

cdecl "strlen"
private expect foreign unsafe function __c_strlen(cstr: [int8]): int
cdecl "strcmp"
private expect foreign unsafe function __c_strcmp(firstCStr: [int8], secondCStr: [int8]): int
cdecl "s_strdup"
private expect foreign unsafe function __c_strdup(cstr: [int8]): [int8]
cdecl "strncmp"
private expect foreign unsafe function __c_strncmp(firstCStr: [int8], secondCStr: [int8], amount: int): int
cdecl "s_strcpy"
private expect foreign unsafe function __c_strcpy(dest: [int8], src: [int8]): [int8]
cdecl "strcat"
private expect foreign unsafe function __c_strcat(dest: [int8], src: [int8]): [int8]
cdecl "strtok"
private expect foreign unsafe function __c_strtok(:any, :[int8]): [int8]?

final sealed struct str is Equatable, Cloneable, Stringifyable, Iterable
  private decl data: [int8]
  private decl length: int
  private decl hash: uint

  function +(other: str): str
    other self:prepend return
  end

  function +(number: int): str
    number:toString self:prepend return
  end

  function +(number: float): str
    number:toString self:prepend return
  end

  function +(cStr: [int8]): str
    cStr str::new self:prepend return
  end

  function clone(): str
    self.data str::new return
  end

  function append(other: str): str
    other.data self:append return
  end

  function append(cStr: [int8]): str
    unsafe
      self.data cStr concat str::new return
    end
  end

  function prepend(other: str): str
    other.data self:prepend return
  end

  function prepend(cStr: [int8]): str
    unsafe
      cStr self.data concat str::new return
    end
  end

  function equals(other: any): bool
    if other is str ! then
      false return
    fi
    self.hash other as str.hash == return
  end

  function ==(other: any): bool
    other self:equals return
  end

  function !=(other: any): bool
    other self:equals ! return
  end

  function size(): int
    self.length return
  end

  function at(i: int): int
    if i 0 < i self:size >= || then
      "Index " i:toString +
      " is out of bounds for string with length " +
      self:size:toString +
      IndexOutOfBoundsException::new throw
    fi
    self.data as int i + @:toInt8 as int return
  end

  function toString(): str
    self return
  end

  function @(i: int): int
    i self:at return
  end

  function [](index: int): int8
    index self:at return
  end

  function reverse(): str
    self:size any::new as [int8] => decl out: [int8]
    0 => decl i: int
    unsafe
      for i in self.length 1 - to -1 step -- do
        self.length i - 1 - self @ => @(out as int i +)
      done
      '\0' => @(out as int self.length +)
    end
    out str::new
    out any::delete
    return
  end

  function toChars() _arr_: Array
    self:size Array::new => _arr_

    for _i_ in 0 to self:size do
      _i_ self:at _arr_:push
    done
    return
  end

  function split(delimiter: str): Array
    10 Array::new => decl arr: Array
    unsafe  
      self:view __c_strdup => decl string: [int8]
      delimiter:view __c_strdup => decl cDelim: [int8]

      string cDelim __c_strtok => decl line

      while line do
        line!! str::new arr:push
        nil cDelim __c_strtok => line
      done
      string any::delete
      cDelim any::delete

    end
    arr return
  end

  function startsWith(string: str): bool
    unsafe
      self.data string.data string:size __c_strncmp 0 == return
    end
  end

  function endsWith(string: str): bool
    if self.length string.length < then
      false return
    fi
    self.length string.length - self:subString => decl substr: str
    substr string ==
    
    substr any::delete

    return
  end

  function subString(start: int): str
    if start 0 == then
      self return
    fi
    if start self.length >= start 0 < || then
      "Index " start:toString +
      " is out of bounds for string with length " self:size:toString +
      +
      IndexOutOfBoundsException::new throw
    fi

    self.data => decl tmp: any

    tmp as int start + => tmp
    tmp as [int8] str::new return
  end

  function view(): [int8]
    unsafe
      self.data __c_strdup return
    end
  end

  function init(data: [int8]): none
    unsafe
      data __c_strdup => data
      data __c_strlen => self.length
    end
    data => self.data
    data builtinHash => self.hash
  end

  function iterate(): StringIterator
    self StringIterator::new return
  end

  function hashCode(): int
    self.hash return
  end

  function finalize(): none
    self.data any::delete
  end

  static function =>(cStr: [int8]): str
    cStr str::new return
  end

  static function of(cStr: [int8]): str
    "" => decl s: str
    unsafe
      cStr __c_strlen => s.length
    end
    s.data any::delete
    cStr => s.data
    cStr builtinHash => s.hash
    s return
  end

  static function filter(arr: str, f: lambda(int8): bool): str
    new<int8>[arr:size] => decl result: [int8]
    0 => decl acc: int
    foreach char in arr do
      if char f:accept then
        char => result[acc]
        acc 1 +> acc
      fi
    done
    acc result:resize str::of return
  end

  static function map(arr: str, f: lambda(int8): int8): str
    new<int8>[arr:size] => decl result: [int8]
    for i in 0 to arr:size do
      arr[i] f:accept => result[i]
    done
    result str::of return
  end

  static function reduce(arr: str, f: lambda(int, int8): int): int
    decl result: int
    for i in 0 to arr:size do
      result arr[i] f:accept => result
    done
    result return
  end

  static function count(arr: str, f: lambda(int8): bool): int
    decl acc: int
    foreach val in arr do
      if val f:accept then
        acc 1 +> acc
      fi
    done
    acc return
  end

  static function each(arr: str, f: lambda(int8): none): none
    foreach val in arr do
      val f:accept
    done
  end

  static function also(arr: str, f: lambda(int8): bool): str
    foreach val in arr do
      val f:accept
    done
    arr return
  end

  static function transform(arr: str, f: lambda(str): any): any
    arr f:accept return
  end

  private unsafe function concat(firstCStr: [int8], secondCStr: [int8]): [int8]
    firstCStr __c_strlen => decl len: int
    secondCStr __c_strlen => decl len2: int
    new<int8>[len len2 + 1 +] => decl out: [int8]

    out firstCStr __c_strcpy drop
    out secondCStr __c_strcat drop

    out return
  end
end

final sealed struct StringIterator is Iterator
  private decl _str: str
  private decl _pos: int

  function init(s: str): none
    s => self._str
    0 => self._pos
  end

  function next(): int8
    self._pos 1 + => self._pos
    self._str[self._pos 1 -] return
  end

  function hasNext(): bool
    self._pos self._str:size < return
  end
end

function +(s: str, i: int): str
  s i:toString + return
end

function +(s: str, f: float): str
  s f:toString + return
end
