import std.math

cdecl "strlen"
private expect foreign unsafe function __c_strlen(cstr: [int8]): int
cdecl "strcmp"
private expect foreign unsafe function __c_strcmp(firstCStr: [int8], secondCStr: [int8]): int
cdecl "s_strdup"
private expect foreign unsafe function __c_strdup(cstr: [int8]): [int8]
cdecl "strncmp"
private expect foreign unsafe function __c_strncmp(firstCStr: [int8], secondCStr: [int8], amount: int): int
cdecl "s_memcpy"
private expect foreign unsafe function __c_memcpy(dest: [int8], src: [int8], count: int): [int8]
cdecl "strcat"
private expect foreign unsafe function __c_strcat(dest: [int8], src: [int8]): [int8]
cdecl "strtok"
private expect foreign unsafe function __c_strtok(:any, :[int8]): [int8]?

final struct str is Iterable
  decl data: readonly [int8]
  decl length: readonly int
  decl hash: readonly uint

  function +(:str): str
    self:prepend return
  end
  
  function +(:[int8]): str
    self:prepend return
  end
  
  function +(:int): str
    :toString.data self:prepend return
  end
  
  function +(:float): str
    :toString.data self:prepend return
  end
  
  function +(:float32): str
    :toString.data self:prepend return
  end

  function clone(): str
    self.data str::new return
  end

  function append(other: str): str
    other.data self:append return
  end

  function append(cStr: [int8]): str
    unsafe
      self.data cStr str::concat str::of return
    end
  end

  function prepend(other: str): str
    other.data self:prepend return
  end

  function prepend(cStr: [int8]): str
    unsafe
      cStr self.data str::concat str::of return
    end
  end

  function equals(other: any): bool
    if other is str ! then false return fi
    self.hash other as str.hash == return
  end

  function ==(other: any): bool
    other self:equals return
  end

  function !=(other: any): bool
    other self:equals ! return
  end

  function size(): int
    self.length return
  end

  function at(i: int): int
    if i 0 < i self:size >= || then
      "Index " i:toString +
      " is out of bounds for string with length " +
      self:size:toString +
      IndexOutOfBoundsException::new throw
    fi
    self.data[i] return
  end

  function indexOf(c: int8): int
    for i in 0 to self:size do
      if self[i] c == then
        i return
      fi
    done
    -1 return
  end

  function indexOf(s: str): int
    for i in 0 to self:size do
      for j in 0 to s:size do
        if self[i j +] s[j] != then
          goto next
        fi
      done
      i return
      label next
    done
    -1 return
  end

  function lastIndexOf(c: int8): int
    for i in self:size 1 - to -1 step -- do
      if self[i] c == then
        i return
      fi
    done
    -1 return
  end

  function contains(c: int8): bool
    c self:indexOf 0 > return
  end

  const function toString(): str
    self return
  end

  deprecated![since: "24.2.0", replacement: "str:[]", forRemoval: true]
  function @(i: int): int
    i self:at return
  end

  function [](index: int): int8
    index self:at return
  end

  function reverse(): str
    new<int8>[self:size 1 +] => decl out: [int8]
    0 => decl i: int
    for i in 0 to self.length do
      self[i] => out[self.length i - 1 -]
    done
    out str::of return
  end

  deprecated![since: "24.2.0", replacement: "str:view", forRemoval: true]
  function toChars() arr: Array
    self:size Array::new => arr

    for _i_ in 0 to self:size do
      _i_ self:at arr:push
    done
    return
  end

  function trim(): str
    0 => decl startIndex: int
    self:size => decl endIndex: int
    try
      while self[startIndex] str::isSpace do
        startIndex 1 +> startIndex
      done

      while self[endIndex 1 -] str::isSpace do
        endIndex 1 -> endIndex
      done
    catch typeof IndexOutOfBoundsException
      "" return
    done

    if startIndex endIndex >= then
      "" return
    fi

    (startIndex to endIndex) self:subString return
  end

  function split(delim: str): [str]
    if delim:size 0 == then
      self.data do 'map Char::toString return
    fi

    0 => decl index: int
    0 => decl arrayPtr: int
    new<str>[self:size] => decl arr: [str]
    decl tmpStr: str

    while index self:size < do
      if
        delim.data
        ((self.data as int) index +) as [int8]
        delim.length unsafe __c_strncmp end 0 ==
      then
        tmpStr => arr[arrayPtr]
        arrayPtr++ => arrayPtr
        "" => tmpStr

        delim.length index +> index
      else
        tmpStr self.data[index] Char::toString + => tmpStr

        index++ => index
      fi
    done

    tmpStr => arr[arrayPtr]
    arrayPtr++ => arrayPtr
  
    arrayPtr arr:resize return
  end

  function startsWith(string: str): bool
    unsafe
      self.data string.data string.length __c_strncmp 0 == return
    end
  end

  function endsWith(string: str): bool
    if self.length string.length < then
      false return
    fi
    self.length string.length - self:subString => decl substr: str
    substr string ==
    
    substr any::delete

    return
  end

  function subString(start: int): str
    if start 0 == then
      self return
    fi
    if start self.length >= start 0 < || then
      "Index " start:toString +
      " is out of bounds for string with length " self:size:toString +
      +
      IndexOutOfBoundsException::new throw
    fi

    (start to self.data:size) self.data:slice str::of return
  end

  function subString(range: Range): str
    if range.lower 0 < range.lower self:size >= || then
      "Index " range.lower:toString +
      " in range " +
      range:toString +
      " is out of bounds for string with length " self:size:toString +
      +
      IndexOutOfBoundsException::new throw
    fi
    if range.upper 0 < range.upper self:size > || then
      "Index " range.upper:toString +
      " in range " +
      range:toString +
      " is out of bounds for string with length " self:size:toString +
      +
      IndexOutOfBoundsException::new throw
    fi

    range self.data:slice str::of return
  end

  function view(): [int8]
    unsafe
      self.data __c_strdup return
    end
  end

  init(data: [int8])
    data str::makeNilTerminated => self.data
    data:size 1 - => self.length
    data builtinHash => self.hash
  end

  init(data: [int8], n: int)
    data:size n <. => self.length
    new<int8>[self.length 1 +] => self.data
    for i in 0 to self.length do
      data[i] => self.data[i]
    done
    self.data builtinHash => self.hash
  end

  init()
    c"" => self.data
    0 => self.length
    0 => self.hash
  end

  function iterate(): StringIterator
    self StringIterator::new return
  end

  function hashCode(): int
    self.hash return
  end

  function utfLength(): int
    self do 'reduce (0) lambda(acc: int, val: int8): int
      if val as uint8 0b11000000u8 & 0b10000000u8 == then
        acc return
      else
        acc++ return
      fi
    end return
  end

  static function format(fmt: str, args: varargs): str
    fmt args str::vformat return
  end

  static function vformat(fmt: str, args: [any]): str
    decl out: str
    
    0 => decl current: int
    args:size => decl size: int
    for i in 0 to fmt:size do
      fmt[i] => decl c: int8
      if c '%' == then
        i++ => i
        fmt[i] => c
        if c '%' == then
          out "%" + => out
          continue
        fi
        if current size >= then
          "Not enough arguments for format string" InvalidArgumentException::new throw
        fi
        args[current] => decl arg: any
        current++ => current
        if c 'i' == then
          out arg as int + => out
        elif c 's' == then
          out arg as str + => out
        elif c '@' == then
          if arg then
            out arg as SclObject:toString + => out
          else
            out "(nil)" + => out
          fi
        elif c 'f' == then
          out arg float::fromBits:toString + => out
        elif c 'p' == then
          out arg int::toHexString + => out
        elif c 'b' == then
          out arg bool::toString + => out
        elif c 'c' == then
          out arg Char::toString + => out
        else
          "Invalid format specifier at position #" i + InvalidArgumentException::new throw
        fi
      else
        out c Char::toString + => out
      fi
    done
    out return
  end

  static function =>(:[int8]): str str::new return end

  static function of(data: [int8]): str
    data str::makeNilTerminated => data
    data builtinHash => decl hash: int
    str {
      (data:size 1 -) => length
      data => data
      hash => hash
    } return
  end

  static function filter(arr: str, f: lambda(int8): bool): str
    new<int8>[arr.length 1 +] => decl result: [int8]
    0 => decl acc: int
    foreach c in arr do
      if c f:accept then
        c => result[acc]
        acc 1 +> acc
      fi
    done
    acc result:resize str::of return
  end

  static function map(arr: str, f: lambda(int8): int8): str
    new<int8>[arr.length 1 +] => decl result: [int8]
    for i in 0 to arr:size do
      arr[i] f:accept => result[i]
    done
    result str::of return
  end

  static function mapIndexed(arr: str, f: lambda(int8, int): int8): str
    new<int8>[arr.length 1 +] => decl result: [int8]
    for i in 0 to arr:size do
      arr[i] i f:accept => result[i]
    done
    result str::of return
  end

  static reified function map<lambda(int8): U>(arr: str, f: lambda(int8): U): [U]
    new<U>[arr:size] => decl result: [U]
    for i in 0 to arr:size do
      arr[i] f:accept => result[i]
    done
    result return
  end

  static reified function mapIndexed<lambda(int8, int): U>(arr: str, f: lambda(int8, int): U): [U]
    new<U>[arr:size] => decl result: [U]
    for i in 0 to arr:size do
      arr[i] i f:accept => result[i]
    done
    result return
  end

  static function reduce(result: int, arr: str, f: lambda(int, int8): int): int
    for i in 0 to arr:size do
      result arr[i] f:accept => result
    done
    result return
  end

  static function count(arr: str, f: lambda(int8): bool): int
    decl acc: int
    foreach val in arr do
      if val f:accept then
        acc 1 +> acc
      fi
    done
    acc return
  end

  static function each(arr: str, f: lambda(int8): none): none
    foreach val in arr do
      val f:accept
    done
  end

  static function also(arr: str, f: lambda(int8): none): str
    foreach val in arr do
      val f:accept
    done
    arr return
  end

  static reified function transform<lambda(str): U>(arr: str, f: lambda(str): U): U
    arr f:accept return
  end

  private static function isSpace(c: int8): bool
    c ' ' == c '\t' == || c '\n' == c '\r' == || || c '\0' == || return
  end

  private static unsafe function concat(firstCStr: [int8], secondCStr: [int8]): [int8]
    firstCStr __c_strlen => decl len: int
    secondCStr __c_strlen => decl len2: int
    new<int8>[len len2 + 1 +] => decl out: [int8]

    out firstCStr len __c_memcpy drop
    out secondCStr __c_strcat drop

    out return
  end

  private static function makeNilTerminated(what: [int8]): [int8]
    if what is [int8] then
      if what:last 0 == then
        what return
      else
        unsafe
          what:size => decl len: int
          new<int8>[len 1 +] what len __c_memcpy return
        end
      fi
    else
      unsafe
        what __c_strdup return
      end
    fi
  end
end

final struct StringIterator is Iterator
  private decl _str: str
  private decl _pos: int

  init(s: str)
    s => self._str
    0 => self._pos
  end

  function next(): int8
    self._pos 1 + => self._pos
    self._str[self._pos 1 -] return
  end

  function hasNext(): bool
    self._pos self._str:size < return
  end
end

function +(s: str, i: int): str
  s i:toString + return
end

function +(s: str, f: float): str
  s f:toString + return
end
