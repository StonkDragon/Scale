final sealed open struct IllegalAccessException: Exception

layout StructBaseLayout
    decl type: int
    decl typeName: [int8]
    decl superStruct: int
    decl binarySize: int
    decl mutex: any
end

final sealed struct Struct
    private static decl structLock: SclObject

    construct function StructCInit(): none
        SclObject::new => structLock
    end

    private decl typeName: str
    private decl typeId: int
    private decl superStruct: Struct?
    private decl binarySize: int
    private decl membersCount: int
    private decl members: [any]

    decl isStatic: readonly bool

    static decl structsCount: const int

    private function init(): none
        "Direct instantiation of struct 'Struct' is disabled!"
        IllegalStateException::new throw
    end

    private expect static unsafe cdecl "_scl_add_struct" function addStruct0(:any): none
    private expect static unsafe cdecl "_scl_mutex_new" function mutexNew0(): any

    function newInstance() inst: SclObject
        if self.isStatic then
            "Can not instantiate static struct '" self.typeName + "'" +
            IllegalStateException::new throw
        fi

        self.binarySize any::new => inst
        inst as StructBaseLayout => decl instanceLayout: mut StructBaseLayout

        self.binarySize => instanceLayout.binarySize
        if self.superStruct then
            self.superStruct!!.typeId
        else
            0
        fi => instanceLayout.superStruct

        self.typeId => instanceLayout.type
        self.typeName:view => instanceLayout.typeName

        unsafe
            mutexNew0 => instanceLayout.mutex
            inst addStruct0
        end
        inst:init
        return
    end

    function getMemberValue(instance: SclObject, name: str) val: any
        false => decl found: bool
        Process::stackTrace => decl frame: Array
        false => decl isInStruct: bool
        if self.typeName ":" + frame.count 2 - frame:get as str :startsWith then
            true => isInStruct
        fi
        decl readSuccessful: bool
        unsafe
            c!
                for (scl_int i = 0; i < (*self)->membersCount; i++) {
                    struct _scl_membertype member = ((struct _scl_membertype*) (*self)->members)[i];
                    if (member.pure_name == (*name)->_hash) {
                        // private
                        int canRead = (member.access_flags & 0b10000 ? *isInStruct : 1);

                        if (canRead) {
                            *val = *(scl_any*) ((*(scl_int*) instance) + member.offset);
                            *readSuccessful = 1;
                        }
                        *found = 1;
                        break;
                    }
                }
            end
        end
        unless found then
            NullPointerException::new => decl e: mut Exception
            "Couldn't find variable '" name +
            "' on struct '" +
            self.typeName +
            "'" + => e.msg
            e throw
        fi

        unless readSuccessful then
            IllegalAccessException::new => decl e: mut Exception
            "Variable '" name +
            "' is private!" + => e.msg
            e throw
        fi
        return
    end

    private expect unsafe function setAccessible0(accessible: bool, name: str): bool

    unsafe function setAccessible(accessible: bool, name: str): none
        accessible name setAccessible0 => decl found: bool

        unless found then
            NullPointerException::new => decl e: mut Exception
            "Couldn't find variable '" name +
            "' on struct '" +
            self.typeName +
            "'" + => e.msg
            e throw
        fi
    end

    function setMemberValue(instance: SclObject, name: str, val: any): none
        false => decl found: bool
        Process::stackTrace => decl frame: Array
        false => decl isInStruct: bool
        if self.typeName ":" + frame.count 2 - frame:get as str :startsWith then
            true => isInStruct
        fi
        decl writeSuccessful: bool
        unsafe
            c!
                for (scl_int i = 0; i < (*self)->membersCount; i++) {
                    struct _scl_membertype member = ((struct _scl_membertype*) (*self)->members)[i];
                    if (member.pure_name == (*name)->_hash) {
                        int canWrite =
                            // const
                            (member.access_flags & 0b01000) == 0 &&
                            // readonly and private
                            (member.access_flags & 0b10010 ? *isInStruct : 1);

                        if (canWrite) {
                            *(scl_any*) ((*(scl_int*) instance) + member.offset) = *val;
                            *writeSuccessful = 1;
                        }
                        *found = 1;
                        break;
                    }
                }
            end
        end

        unless found then
            NullPointerException::new => decl e: mut Exception
            "Couldn't find variable '" name +
            "' on struct '" +
            self.typeName +
            "'" + => e.msg
            e throw
        fi

        unless writeSuccessful then
            IllegalAccessException::new => decl e: mut Exception
            "Variable '" name +
            "' is not writable from the current scope!" + => e.msg
            e throw
        fi
    end

    private expect static unsafe cdecl "_scl_get_method_handle" function getMethodByName0(:int, :int): lambda

    function getMethodByName(name: str) method: lambda
        self:lock
        unsafe
            self.typeId name:hashCode getMethodByName0 => method
        end
        unless method then
            NullPointerException::new => decl e: mut Exception
            "Couldn't find method '" name +
            "' on struct '" +
            self.typeName +
            "'" + => e.msg
            e
            self:lock
            throw
        fi
        self:lock
        return
    end

    function getName(): str
        self.typeName return
    end

    function getSize(): int
        self.binarySize return
    end

    function getSuper(): Struct?
        self.superStruct return
    end

    private expect static unsafe cdecl "_scl_get_struct_by_id" function getStructByName0(:int): Struct

    static function getStructByName(name: str): Struct
        Struct::structLock:lock
        decl theStruct: Struct?
        unsafe
            name:hashCode getStructByName0 => theStruct
        end
        
        unless theStruct then
            NullPointerException::new => decl e: mut Exception
            "Couldn't find struct '" name + "'" + => e.msg
            e
            Struct::structLock:lock
            throw
        fi
        theStruct!!
        Struct::structLock:lock
        return
    end
end
