final sealed struct ThreadException : Exception
    function init(msg: str): none
        msg => self.msg
    end
end

final sealed struct AtomicOperationException : Exception
    function init(msg: str): none
        msg => self.msg
    end
end

typealias pthread_t "pthread_t"
typealias pthread_mutex_t "pthread_mutex_t"
typealias pthread_mutexattr_t "pthread_mutexattr_t"

cdecl "pthread_mutex_init"    private expect unsafe function __c_pthread_mutex_init(:[pthread_mutex_t], :[pthread_mutexattr_t]?): int32
cdecl "pthread_mutex_lock"    private expect unsafe function __c_pthread_mutex_lock(:[pthread_mutex_t]): int32
cdecl "pthread_mutex_unlock"  private expect unsafe function __c_pthread_mutex_unlock(:[pthread_mutex_t]): int32
cdecl "pthread_mutex_destroy" private expect unsafe function __c_pthread_mutex_destroy(:[pthread_mutex_t]): int32
cdecl "GC_pthread_create"     private expect unsafe function __c_pthread_create(:[pthread_t?], :any?, :any, :any?): none
cdecl "GC_pthread_join"       private expect unsafe function __c_pthread_join(:pthread_t, :any?): none
cdecl "pthread_self"          private expect unsafe function __c_pthread_self(): pthread_t

final sealed struct Thread
    private static decl threads: Array
    private static decl nextID: int

    static decl mainThread: readonly Thread

    private decl func: lambda(): none
    private decl tid: pthread_t?

    decl name: str

    construct function __privateInit(): none
        0 => Thread::nextID
        1 TypedArray<Thread>::new => Thread::threads
    end

    static function stackTrace(): Array
        Process::stackTrace return
    end

    private static expect unsafe cdecl "_scl_get_main_addr" function mainAddress(): lambda

    expect static function currentThread(): Thread

    function init(func: lambda(): none): none
        func => self.func
        nil => self.tid
        "Thread " Thread::nextID:toString + => self.name
        Thread::nextID 1 + => Thread::nextID
    end

    private expect unsafe function start0(): int
    private expect unsafe function stop0(): int
    private expect unsafe function run(): none

    function start(): none
        if tid then
            "Thread started" ThreadException::new
            throw
        fi
        unsafe
            self:start0 => decl res: int
            if res 0 != then
                "Thread start failed" ThreadException::new
                throw
            fi
        end
    end

    function join(): none
        unless tid then
            "Thread ended" ThreadException::new
            throw
        fi
        unsafe
            self:stop0 => decl res: int
            if res 0 != then
                "Thread join failed" ThreadException::new
                throw
            fi
        end
        nil => self.tid
    end

    function equals(other: any): bool
        if other is Thread ! then
            false return
        fi
        other as Thread:lock
        self other as Thread ==
        other as Thread:unlock
        return
    end

    function ==(other: any): bool
        if other is Thread ! then
            false return
        fi
        other as Thread:lock
        self.tid as int other as Thread.tid as int ==
        other as Thread:unlock
        return
    end
end
