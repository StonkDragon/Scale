final struct Fraction
    decl numerator: int
    decl denominator: int

    function init(numerator: int, denominator: int): none
        numerator denominator Fraction::gcd => decl div

        numerator div / => self.numerator
        denominator div / => self.denominator
    end

    function toString(): str
        numerator int::toString "/" + denominator int::toString + return
    end

    function toFloat(): float
        numerator as float denominator as float / return
    end

    function +(other: Fraction): Fraction
        self.denominator other.numerator *
        self.numerator other.denominator *
        +
        self.denominator other.denominator *
        Fraction::new return
    end

    function -(other: Fraction): Fraction
        self.denominator other.numerator *
        self.numerator other.denominator *
        -
        self.denominator other.denominator *
        Fraction::new return
    end

    function ++(): Fraction
        self.numerator self.denominator + => self.numerator
        self return
    end

    function --(): Fraction
        self.numerator self.denominator - => self.numerator
        self return
    end

    function *(other: Fraction): Fraction
        self.numerator other.numerator *
        self.denominator other.denominator *
        Fraction::new return
    end

    function inverse(): Fraction
        self.denominator self.numerator Fraction::new return
    end

    function /(other: Fraction): Fraction
        other self:inverse * return
    end

    function isNan(): bool
        self.numerator 0 == self.denominator 0 == && return
    end

    function isInfinite(): bool
        self.denominator 0 == return
    end

    function isFinite(): bool
        self:isInfinite ! return
    end

    function isNotNan(): bool
        self:isNan ! return
    end

    static function fromFloat(d: float): Fraction
        0 => decl num: int
        0 => decl den: int
        d float::toString:view => decl s

        c!
            if (isnan(*d)) {
                *num = 0;
                *den = 0;
            } else if (isinf(*d)) {
                *num = 1;
                *den = 0;
            } else {
                char whole[strlen(*s)];
                char decimal[strlen(*s)];
                int whole_ptr = 0;
                int decimal_ptr = 0;

                int hasWholePart = 1;
                int hasDecimalPart = 0;
                int sign = 1;

                for (int i = 0; i < strlen(*s); i++) {
                    if ((*s)[i] == '.') {
                        hasWholePart = 0;
                        hasDecimalPart = 1;
                        continue;
                    }
                    if ((*s)[i] == '-') {
                        sign = -1;
                        continue;
                    }
            
                    if (hasWholePart)
                        whole[whole_ptr++] = (*s)[i];
            
                    if (hasDecimalPart)
                        decimal[decimal_ptr++] = (*s)[i];
                }

                int num_whole = strtol(whole, NULL, 10);
                int num_decimal = 0;
            
                if (strlen(decimal) != 0)
                    num_decimal = strtol(decimal, NULL, 10);

                int numerator = num_whole * pow(10, strlen(decimal)) + num_decimal;
                numerator *= sign;
            
                int denominator = pow(10, strlen(decimal));
            
                int gd = Function_Fraction$gcd(numerator, denominator);

                *num = numerator / gd;
                *den = denominator / gd;
            }
        end

        num den Fraction::new return
    end

    private static function gcd(a: int, b: int): int
        if a 0 == then b return fi
        if b 0 == then a return fi
        if a 0 < then a -1 * => a fi
        if b 0 < then b -1 * => b fi

        while a b != do
            if a b > then
                a b - => a
            else
                b a - => b
            fi
        done

        a return
    end
end
