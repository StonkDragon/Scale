import Scale.util.stringifyable

cdecl "strlen"
expect function __c_strlen(_str_: [int8]) len: int
cdecl "strcmp"
expect function __c_strcmp(_str1_: [int8], _str2_: [int8]): int
cdecl "strdup"
expect function __c_strdup(_str_: [int8]): [int8]
cdecl "strncmp"
expect function __c_strncmp(_str1_: [int8], _str2_: [int8], _n_: int): int
cdecl "strcpy"
expect function __c_strcpy(dest: [int8], src: [int8]): [int8]

sealed struct str is IEquatable, ICloneable, IStringifyable
  private decl _data: [int8]
  private decl _len: int

  function +(other: str): str
    other self:prepend return
  end

  function clone(): str
    self:view str::new return
  end

  function append(other: str): str
    self._data other._data concat str::new return
  end

  function prepend(other: str): str
    other._data self._data concat str::new return
  end

  function equals(other: str): bool
    self._data other._data __c_strcmp 0 == return
  end

  function ==(other: str): bool
    other self:equals return
  end

  function size(): int
    self._len return
  end

  function at(i: int): int
    if i 0 < i self:size >= || then
      nameof i " is out of bounds" + IndexOutOfBoundsException::new throw
    fi
    self._data i + @ toInt8 as int return
  end

  function toString(): str
    self return
  end

  function @(i: int): int
    i self:at return
  end

  function reverse(): str
    decl out: [int8]
    c!
      scl_int i = 0;
      scl_int len = strlen((*self)->_data);
      *out = _scl_alloc(len + 1);
      for (i = len - 1; i >= 0; i--) {
        (*out)[i] = (*self)->_data[len - i - 1];
      }
      (*out)[len] = '\0';
    end
    out str::new return
  end

  function toChars() _arr_: Array
    self:size Array::new => _arr_

    for _i_ in 0 to self:size do
      _i_ self:at _arr_:push
    done
    return
  end

  function split(_delim_: str): Array
    10 Array::new => decl arr: Array
    self:view => decl string
    string _delim_:view __c_strtok => decl line

    while line do
      line!! str::new arr:push
      nil _delim_:view __c_strtok => line
    done
    arr return
  end

  function startsWith(_s_: str): bool
    self._data _s_._data _s_:size __c_strncmp 0 == return
  end

  function view(): [int8]
    self._data __c_strdup return
  end

  function init(data: [int8]): none
    data => self._data
    data __c_strlen => self._len
  end

  function hashCode(): int
    if self:size 0 == then
      0 return
    fi
    7 => decl h
    for i in 0 to self:size do
      h 31 * i self @ + => h
    done
    h return
  end

  private function concat(_str1_: [int8], _str2_: [int8]): [int8]
    decl out: [int8]
    _str1_ __c_strlen => decl len: int
    _str2_ __c_strlen => decl len2: int

    len len2 + 1 + malloc => out

    out _str1_ __c_strcpy drop
    c!
      strcat(*out, *_str2_);
    end

    out return
  end
end
