import Scale.util.iterable

sealed struct Range is IIterable
  decl lower: int
  decl upper: int
  
  private decl pos: int

  export function init(_start: int, _end: int): none
    if _start _end > then
      "start must not be bigger than end! Use ReverseRange if you want that" eputs trace 1 exit
    fi

    _start => self.lower
    _end => self.upper
    0 => self.pos
  end

  export function containsRange(other: Range): int
    if other.lower self:contains other.upper self:contains && then
      true return
    fi
    false return
  end

  export function overlaps(other: Range): int
    if other.lower self:contains other.upper self:contains || then
      true return
    fi
    false return
  end

  export function contains(pos: int): int
    if pos self.lower >= then
      if pos self.upper <= then
        true return
      fi
    fi
    false return
  end

  function toString(): str
    lower longToString " .. " + upper longToString + return
  end

  function hasNext(): bool
    self.pos self.lower + self.upper <= return
  end

  function next(): int
    self.lower self.pos +
    self.pos 1 + => self.pos
    return
  end

  export function toReverseRange(): ReverseRange
    self.upper self.lower ReverseRange::new return
  end
end

sealed struct ReverseRange is IIterable
  decl lower: int
  decl upper: int
  decl pos: int

  export function init(_start: int, _end: int): none
    if _start _end < then
      "end must not be bigger than start! Use Range if you want that" eputs trace 1 exit
    fi
      
    _start => self.lower
    _end => self.upper
    0 => self.pos
  end

  function toString(): str
    lower longToString " .. " + upper longToString + return
  end
  
  function hasNext(): bool
    self.lower self.pos - self.upper >= return
  end

  function next(): int
    self.lower self.pos -
    self.pos 1 + => self.pos
    return
  end

  export function toRange(): Range
    self.upper self.lower Range::new return
  end
end
