import Scale.util.iterable
import Scale.util.immutablearray
import Scale.debug
import Scale.util.arg
import Scale.util.bounds

sealed struct Array is IIterable, IFinalizable
  decl values:  mut readonly [any]
  decl count:       readonly int
  decl capacity:    readonly int

  private decl pos: readonly int
  
  function sort(): none
    inline_c
      scl_int i = 0;
      while (i < (scl_int) (*self)->count) {
        scl_int speicher = (scl_int) Method_Array_get(i, (*self));
        scl_int j = i - 1;
        while (j >= 0) {
          if (speicher < (scl_int) Method_Array_get(j, (*self))) {
            Method_Array_set(j + 1, Method_Array_get(j, (*self)), (*self));
            Method_Array_set(j, (scl_any) speicher, (*self));
          } else {
            Method_Array_set(j + 1, (scl_any) speicher, (*self));
            break;
          }
          j--;
        }
        i++;
      }
    end_inline
  end

  function get(index: int): any?
    if index 0 < index self.count >= || then
      "Index "
      index longToString +
      " is out of bounds for Array of length " +
      self.count longToString +
      "!" +
      IndexOutOfBoundsException::new throw
    fi
    self.values index sizeof int * + @ return
  end

  function set(index: int, value: any): none
    if index 0 < index self.capacity >= || then
      "Index "
      index longToString +
      " is out of bounds for Array of capacity " +
      self.capacity longToString +
      "!" +
      IndexOutOfBoundsException::new throw
    fi
    if index self.count >= then
      index 1 + => self.count
    fi
    decl tmp: mut [any]
    self.values index sizeof int * + => tmp
    value => @tmp
  end

  function top(): any?
    if self.count 0 <= then
      "Cannot invoke Array:top on an empty Array!" IndexOutOfBoundsException::new throw
    fi
    self.values self.count 1 - sizeof int * + @ return
  end

  function push(value: any): none
    if self.count self.capacity >= then
      self.capacity 2 * => self.capacity
      self.capacity sizeof int * self.values realloc
      => self.values
    fi

    decl tmp: mut [any]
    self.values self.count sizeof int * + => tmp
    value => @tmp
    self.count 1 + => self.count
  end

  function pop(): none
    if self.count 0 <= then
      "Cannot invoke Array:pop on an empty Array!" IndexOutOfBoundsException::new throw
    fi
    self.count 1 - => self.count
  end

  function contains(val: any): bool
    for i in 0 to self.count do
      if i self:get val == then
        true return
      fi
    done
    false return
  end

  function init(size: int): none
    if size 1 < then
      "Invalid Argument: size must not be 0 or less" InvalidArgumentException::new throw
    fi
    size sizeof int * malloc
    => self.values
    0 => self.count
    0 => self.pos
    size => self.capacity
  end

  function hasNext(): bool
    self.pos self.count < return
  end

  function next(): any?
    self.pos 1 + => self.pos
    if self:hasNext ! then
      nil return
    fi

    self.pos self:get return
  end

  function begin(): any?
    0 self:get
    0 => self.pos
    return
  end

  function toString() s: str
    if self.count 0 == then
      "{}" => s
    else
      "{" => s
      for i in 0 to self.count do
        i self:get => decl elem: any
        if i then
          s ", " + => s
        fi
        if elem is SclObject then
          elem as SclObject :toString => decl asStr
          s asStr + => s
        else
          s elem as int longToString + => s
        fi
      done
      s "}" + => s
    fi
    return
  end

  function finalize(): none
    self.values free
    -1 => self.count
  end

  function immutableCopy(): ImmutableArray
    self.count sizeof int * malloc => decl newVals: [any]
    newVals self.values self.count sizeof int * memcpy => newVals
    self.count => decl newCount: int

    newCount newVals ImmutableArray::new return
  end

  function map(x: lambda(any): none): none
    foreach elem in self do
      elem x:accept
    done
  end

  function filter(x: lambda(any): bool) arr: Array
    self.capacity Array::new => arr
    foreach elem in self do
      if elem x:accept then
        elem arr:push
      fi
    done
    return
  end

  static function fromPointerCollection(count: int, values: [any]) arr: Array
    count Array::new => arr
    for i in 0 to count do
      values i sizeof int * + @ arr:push
    done
    return
  end
end
