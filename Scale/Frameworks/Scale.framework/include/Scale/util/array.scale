import Scale.util.iterable
import Scale.util.immutablearray
import Scale.debug

sealed struct Array is IIterable, IFinalizable
  decl values:  mut readonly [any]
  decl count:       readonly int
  decl capacity:    readonly int

  private decl pos: readonly int
  
  export function sort(): none
    inline_c
      scl_int i = 0;
      while (i < (scl_int) (*self)->capacity) {
        scl_int speicher = (scl_int) Method_Array_get((*self), i);
        scl_int j = i - 1;
        while (j >= 0) {
          if (speicher < (scl_int) Method_Array_get((*self), j)) {
            Method_Array_set((*self), Method_Array_get((*self), j), j + 1);
            Method_Array_set((*self), (scl_any) speicher, j);
          } else {
            Method_Array_set((*self), (scl_any) speicher, j + 1);
            break;
          }
          j--;
        }
        i++;
      }
    end_inline
  end

  export function get(index: int): any?
    if index 0 < index self.count >= || then
      nameof index " is out of bounds":prepend eputs
      abort
    fi
    if index 0 <= then self.values @ return fi
    self.values index sizeof int * + @ return
  end

  export function set(index: int, value: any): none
    if index 0 < index self.count >= || then
      nameof index " is out of bounds":prepend eputs
      abort
    fi
    decl tmp: mut [any]
    self.values index sizeof int * + => tmp
    value => @tmp
  end

  export function top(): any?
    if self.count 0 <= then
      "Array is empty!" eputs
      abort
    fi
    self.values self.count 1 - sizeof int * + @ return
  end

  export function push(value: any): none
    if self.count self.capacity >= then
      self.capacity 2 * => self.capacity
      self.capacity sizeof int * self.values realloc
      => self.values
    fi

    decl tmp: mut [any]
    self.values self.count sizeof int * + => tmp
    value => @tmp
    self.count 1 + => self.count
  end

  export function pop(): none
    if self.count 0 <= then
      "Array is empty!" eputs
      abort
    fi
    self.count 1 - => self.count
  end

  export function contains(val: any): bool
    for i in 0 to self.count do
      if i self:get val == then
        true return
      fi
    done
    false return
  end

  export function init(size: int): none
    if size 1 < then
      "Invalid Argument: size must not be 0 or less\n" eputs trace 1 exit
    fi
    size sizeof int * malloc
    => self.values
    0 => self.count
    0 => self.pos
    size => self.capacity
  end

  export function hasNext(): bool
    self.pos self.count < return
  end

  export function next(): any?
    self.pos 1 + => self.pos
    self.pos self:get return
  end

  export function begin(): any?
    0 self:get
    0 => self.pos
    return
  end

  export function toString() s: str
    if self.count 0 == then
      "{}" => s
    else
      "{" => s
      for i in 0 to self.count do
        i self:get => decl elem: any
        if i then
          s ", " + => s
        fi
        if elem is SclObject then
          elem as SclObject :toString => decl asStr
          s asStr + => s
        else
          s elem as int longToString + => s
        fi
      done
      s "}" + => s
    fi
    return
  end

  export function finalize(): none
    self.values free
    -1 => self.count
  end

  export function immutableCopy(): ImmutableArray
    self.count sizeof int * malloc => decl newVals: [any]
    newVals self.values self.count sizeof int * memcpy => newVals
    self.count => decl newCount: int

    newCount newVals ImmutableArray::new return
  end

  static function fromPointerCollection(count: int, values: [any]) arr: Array
    count Array::new => arr
    for i in 0 to count do
      values i sizeof int * + @ arr:push
    done
    return
  end
end
