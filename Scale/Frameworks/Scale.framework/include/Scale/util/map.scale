import Scale.util.pair
import Scale.util.iterable

sealed struct MapEntry
  decl key: str
  decl value: any

  export function init(key: str, value: any): none
    key => self.key
    value => self.value
  end
end

sealed struct Map is IIterable, IFinalizable
  private decl data: Array

  export function init(size: int): none
    size Array::new => self.data
    for i in 0 to size do
      nil self.data:push
    done
  end

  export function get(key: str): any?
    for i in 0 to self.data.count do
      decl entry: MapEntry? i self.data:get => entry
      if entry nil == then continue fi

      entry => decl notNilEntry: MapEntry
      if notNilEntry.key nil == then continue fi
      if key notNilEntry.key == then
        notNilEntry.value return
      fi
    done
    nil return
  end

  export function set(key: str, value: any): none
    for i in 0 to self.data.count do
      i self.data:get => decl entry: mut MapEntry?
      if entry nil == then
        i key value MapEntry::new self.data:set
        return
      elif entry as MapEntry.key key:equals then
        value => entry.value
        return
      fi
    done
    key value MapEntry::new self.data:push
  end

  export function hasNext(): bool
    self.data:hasNext return
  end

  export function next(): MapEntry?
    self.data:next as MapEntry? return
  end

  export function begin(): MapEntry?
    self.data:begin as MapEntry? return
  end
end
