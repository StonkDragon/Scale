import Scale.util.pair
import Scale.util.iterable

sealed struct MapEntry
  decl key: str
  decl value: any

  export function init(key: str, value: any): none
    key => self.key
    value => self.value
  end
end

sealed struct Map is IIterable, IFinalizable
  decl _data: Array!
  decl _pos: int

  export function init(size: int): none
    size Array::new => self._data
    for i in 0 to size do
      nil self._data:push
    done
    0 => self._pos
  end

  export function get(key: str!): any
    for i in 0 to self._data.count do
      decl entry: MapEntry i self._data:get => entry
      if entry nil == then continue fi

      entry => decl notNilEntry: MapEntry!
      if notNilEntry.key nil == then continue fi
      if key notNilEntry.key == then
        notNilEntry.value return
      fi
    done
    nil return
  end

  export function set(key: str!, value: any): none
    for i in 0 to self._data.count do
      i self._data:get => decl entry: mut MapEntry
      if entry nil == then
        i key value MapEntry::new self._data:set
        return
      elif entry as MapEntry!.key key:equals then
        value => entry.value
        return
      fi
    done
    key value MapEntry::new self._data:push
  end

  export function hasNext(): bool
    self._pos self._data Array.count < return
  end

  export function next(): MapEntry!
    self._pos 1 + => self._pos
    self._pos self._data Array:get as MapEntry! return
  end

  export function begin(): MapEntry!
    0 => self._pos
    self._pos self._data Array:get as MapEntry! return
  end
end
