import std.compiler.Utils

macro! parserNext() {
    (
        parser:consume => decl maybeTok: Token?
        if maybeTok nil == then
            MacroError {
                "Expected a token" => msg
                loc => location
            } Result::Err return
        fi
        maybeTok!!
    )
}

foreign function expand(loc: SourceLocation, parser: Parser): Result`<[Token], MacroError>`
    parserNext! => decl tok: Token

    if tok.type TokenType::CurlyOpen != then
        new<Token>{ tok } Result::Ok return
    fi

    1 => decl depth: int
    1 TypedArray<Token>::new => decl tokens
    decl nextTok: Token?
    while depth 1 >= do
        if parser:peek nil == then
            MacroError {
                "Expected a closing curly brace" => msg
                nextTok.location => location
            } Result::Err return
        fi
        parser:consume!! => nextTok
        nextTok!! => decl current: Token

        if current.type TokenType::CurlyClose != depth 1 > || then
            current tokens:push
        fi

        if current.type TokenType::CurlyOpen == then
            depth++ => depth
        elif current.type TokenType::CurlyClose == then
            depth-- => depth
        fi
    done

    new<Token>[tokens.count] => decl expanded: [Token]
    for i in 0 to tokens.count do
        tokens[i] => expanded[i]
    done

    expanded Result::Ok return
end

foreign function quote(loc: SourceLocation, parser: Parser): Result`<[Token], MacroError>`
    parserNext! => decl tok: Token

    if tok.type TokenType::CurlyOpen != then
        new<Token>{
            Token {
                TokenType::StringLiteral => type
                tok.value => value
                loc => location
            }
        } Result::Ok return
    fi

    1 => decl depth: int
    "" => decl s: str
    decl nextTok: Token?
    while depth 1 >= do
        if parser:peek nil == then
            MacroError {
                "Expected a closing curly brace" => msg
                nextTok.location => location
            } Result::Err return
        fi
        parser:consume!! => nextTok
        nextTok!! => decl current: Token

        if current.type TokenType::CurlyClose != depth 1 > || then
            if s:size then
                s " " + => s
            fi
            s current.value + => s
        fi

        if current.type TokenType::CurlyOpen == then
            depth++ => depth
        elif current.type TokenType::CurlyClose == then
            depth-- => depth
        fi
    done

    new<Token>{
        Token {
            TokenType::StringLiteral => type
            s => value
            loc => location
        }
    } Result::Ok return
end

foreign function config(loc: SourceLocation, parser: Parser): Result`<[Token], MacroError>`
    parserNext! => decl tok: Token
    if tok.type TokenType::StringLiteral != then
        MacroError {
            "Expected a string" => msg
            tok.location => location
        } Result::Err return
    fi

    tok.value => decl key: str

    parser:consume!! => tok
    if tok.type TokenType::Is != then
        MacroError {
            "Expected 'is'" => msg
            tok.location => location
        } Result::Err return
    fi

    parser:consume!! => tok
    if tok.type TokenType::StringLiteral != tok.type TokenType::Nil != && then
        MacroError {
            "Expected a string or 'nil'" => msg
            tok.location => location
        } Result::Err return
    fi
    
    tok.type TokenType::Nil == => decl checkExistence: bool
    
    decl value: str
    if checkExistence ! then
        tok.value => value
    fi

    parser:peek!! => tok
    true => decl equals: bool
    if tok.type TokenType::Identifier == tok.value "!" == && then
        false => equals
        parser:consume drop
    fi

    tok.location parser expand => decl block: Result
    if block.isErr then
        block return
    fi

    parser.config => decl conf: Config
    
    decl conditionMet: bool
    if checkExistence then
        key conf:hasKey equals != => conditionMet
    else
        (key conf:getKey value ==) equals == => conditionMet
    fi

    if conditionMet then
        block return
    else
        new<Token>[0] Result::Ok return
    fi
end
