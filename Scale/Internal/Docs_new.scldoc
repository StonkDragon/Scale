# Scale Language Reference
## Keywords: Functions, Structs, ...
### function
The keyword used to create a new function.
Every function has a name, a return type, and 0 or more arguments.
The syntax for creating a function is as follows:

<<BLUE>>function <<WHITE>>foo<<BLUE>>(<<WHITE>>arg<<BLUE>>: int): int<<RESET>>
    <<CYAN>># body<<RESET>>
<<BLUE>>end<<RESET>>

Functions always end with the <<BLUE>>end<<RESET>> keyword.

### lambda
Lambdas are anonomous functions.
A lambda specifies it's arguments and return type in the same way as a function:

<<BLUE>>lambda(<<WHITE>>x<<BLUE>>: int): int<<RESET>>
    <<CYAN>># body
<<BLUE>>end<<RESET>>

### typealias
This keyword is used to create a Scale alias for a C type.
The syntax is as follows:

<<BLUE>>typealias <<WHITE>>ScaleName <<GREEN>>"c_type_t"<<RESET>>

Where the C type must be specified within quotes as it may contain special characters such as '*'
The Scale name must be a valid identifier.

### container
Containers are a legacy feature allowing the grouping of multiple variables.
It is advised to use a static struct (See: <<BLUE>>static<<RESET>>) instead of a container as static structs offer more functionality.
If you still wish to use a container, this is how the syntax works:

<<BLUE>>container <<WHITE>>Container<<RESET>>
    <<CYAN>># variable declarations<<RESET>>
<<BLUE>>end<<RESET>>

### struct
The <<BLUE>>struct<<RESET>> keyword allows you to create your own complex data types.
Structs can contain variables and functions:

<<BLUE>>struct <<WHITE>>Foo<<RESET>>
    <<BLUE>>decl <<WHITE>>x<<BLUE>>: int<<RESET>>

    <<BLUE>>function <<WHITE>>foo<<BLUE>>(): none<<RESET>>
        <<CYAN>># body<<RESET>>
    <<BLUE>>end<<RESET>>

<<BLUE>>end<<RESET>>

Applying the <<BLUE>>static<<RESET>> modifier to a struct automatically makes every member of the struct a static member and disables initialization of the struct.

### self
The <<BLUE>>self<<RESET>> keyword is only available in member functions of structs.
It is used to reference the current instance of the struct inside the function.

### enum
Enums are a collection of named integer constants.
An enum can be created like this:

<<BLUE>>enum <<WHITE>>Bar<<RESET>>
    <<WHITE>>first<<CYAN>> # evaluates to 0<<RESET>>
    <<WHITE>>second<<CYAN>> # evaluates to 1<<RESET>>
    <<WHITE>>third<<CYAN>> # evaluates to 2<<RESET>>
<<BLUE>>end<<RESET>>

### interface
Interfaces provide a way to group and name functionality of a struct.
An interface can be defined like this:

<<BLUE>>interface <<WHITE>>IRandom<<RESET>>
    <<BLUE>>function <<WHITE>>random<<BLUE>>(): int<<RESET>>
<<BLUE>>end<<RESET>>

It is important to remember that functions in an interface may NOT have an implementation, unless the feature 'default-interface-implementation' is enabled.

## Keywords: Modifiers, Visibility, ...
### import
The <<BLUE>>import<<RESET>> keyword is used to import a module (See: <<BLUE>>Frameworks/Modules<<RESET>>) from a Framework.
The syntax is as follows:

<<BLUE>>import <<WHITE>>module<<BLUE>>.<<WHITE>>foo<<RESET>>

### export
The <<BLUE>>export<<RESET>> keyword is used to export a function from the current translation context.
This allows that function to be referenced in a different context using the <<BLUE>>expect<<RESET>> keyword.
The syntax is as follows:

<<BLUE>>export function <<WHITE>>random<<BLUE>>(): int<<RESET>>
    <<CYAN>># body<<RESET>>
<<BLUE>>end<<RESET>>

Using <<BLUE>>export<<RESET>> also has the side effect of making the function visible in C.

### expect
The <<BLUE>>expect<<RESET>> keyword is used to reference a function from a different translation context.
The syntax is as follows:

<<BLUE>>expect function <<WHITE>>random<<BLUE>>(): int<<RESET>>

Functions marked with <<BLUE>>expect<<RESET>> do not have a body.

A side effect of using <<BLUE>>expect<<RESET>> is, that it can reference C functions as well, allowing the use of C functions in scale.

### construct
The <<BLUE>>construct<<RESET>> modifier marks a function as a global constructor, which means that it will run before <<WHITE>>main<<RESET>> and is usually used to set up things before.

### final
The <<BLUE>>final<<RESET>> modifier marks a function as a global destructor, which means that it will run after <<WHITE>>main<<RESET>> and is usually used to clean up things after.

### private
The <<BLUE>>private<<RESET>> modifier is only effective in a struct.
It hides members of the struct from other pieces of code, making them only accessible from other members of the struct.

### cdecl
The <<BLUE>>cdecl<<RESET>> modifier is used to change the symbol of the function.
Together with <<BLUE>>expect<<RESET>> this makes it possible to reference C functions with a different name.

### asm
The <<BLUE>>cdecl<<RESET>> modifier is used to change the symbol of the function.
Together with <<BLUE>>expect<<RESET>> this makes it possible to reference C functions with a different name.

The only difference to <<BLUE>>cdecl<<RESET>> is, that it does not prepend the '_' to the symbol, which some C compilers do.

### static
The <<BLUE>>static<<RESET>> keyword is only effective in structs.
It makes the member it is applied to a static member of the struct, meaning no instance is required to use it.
Applying this modifier to the struct definition itself applies the modifier to every member of the struct.

### decl
The <<BLUE>>decl<<RESET>> keyword is used to create a new variable.
The syntax is as follows:

<<BLUE>>decl <<WHITE>>x<<BLUE>>: <<WHITE>>Type<<RESET>>

Where <<WHITE>>x<<RESET>> is the name and <<WHITE>>Type<<RESET>> is the type of the variable.
Type modifiers may be added immediately in front of the type after the <<BLUE>>:<<RESET>>

### ref
The <<BLUE>>ref<<RESET>> keyword is used to retreive the address of a variable or function.
Taking the reference of a function has one additional feature as it returns a lambda.
The syntax is as follows:

Variable or function:
<<BLUE>>ref<<WHITE>> name

Nested variable:
<<BLUE>>ref<<WHITE>> name<<BLUE>>.<<WHITE>>nested

Struct static members:
<<BLUE>>ref<<WHITE>> StructName<<BLUE>>::<<WHITE>>func

Struct member functions:
Getting the reference of a member function requires an instance.
<<BLUE>>ref<<WHITE>> instance<<BLUE>>::<<WHITE>>func

### typeof
The <<BLUE>>typeof<<RESET>> keyword is used to retreive the type of a variable.
It returns a string containing the type name.
The string returned is the type name of the value stored in the variable and thus will only be fully available at runtime.

<<BLUE>>typeof<<RESET>> can also be applied to functions, in which case the lambda type of the function will be returned.

### nameof
The <<BLUE>>nameof<<RESET>> keyword is used to retreive the name of a variable as a string.

### sizeof
The <<BLUE>>sizeof<<RESET>> keyword is used to retreive the size of a variable.
It returns an <<BLUE>>int<<RESET>>.
Due to most types being a reference type, this will almost certainly return <<GREEN>>8<<RESET>>.

### as
The <<BLUE>>as<<RESET>> keyword is used to cast the current top value on the stack to a different type.
The syntax is as follows:

<<BLUE>>as <<WHITE>>type<<RESET>>

Where <<WHITE>>type<<RESET>> represents a valid scale type.

### is
The <<BLUE>>is<<RESET>> keyword is used to check the type of a given value at runtime.
The syntax is as follows:

<<BLUE>>is <<WHITE>>type<<RESET>>

Where <<WHITE>>type<<RESET>> represents a valid scale type.
This is only useful, if the type is a struct, as for value types this keyword will always return <<BLUE>>true<<RESET>>.

### const
The <<BLUE>>const<<RESET>> type modifier is used to make a variable immutable.
If a variable is immutable, it can only ever be written to inside constructors.

### mut
The <<BLUE>>mut<<RESET>> type modifier is used to make a variable mutable.
This allows it to be deref-written, which means you can write to nested variables using this variable.

### readonly
The <<BLUE>>readonly<<RESET>> type modifier is similar to the <<BLUE>>const<<RESET>> modifier.
It makes it so that a variable can only be written to from inside of the same struct that it was declared in.
This modifier is only effective in structs.

## Keywords: Control flow
### while
The <<BLUE>>while<<RESET>> keyword starts the header of a while-loop.
While-loop syntax is as follows:

<<BLUE>>while <<WHITE>>condition <<BLUE>>do<<RESET>>
    <<CYAN>># body<<RESET>>
<<BLUE>>done<<RESET>>

### if & unless
The <<BLUE>>if <<RESET>>and <<BLUE>>unless<<RESET>> keywords are used for if and unless-statements respectively.
The syntax for an if-statement is as follows:

<<BLUE>>if <<WHITE>>condition <<BLUE>>then<<RESET>>
    <<CYAN>># body<<RESET>>
<<BLUE>>fi<<RESET>>

The value of <<WHITE>>condition<<RESET>> will always be fully evaluated.

For an unless-statement, replace the <<BLUE>>if<<RESET>> with an <<BLUE>>unless<<RESET>>.

### elif & elunless
The <<BLUE>>elif <<RESET>>and <<BLUE>>elunless<<RESET>> keywords are used to add extra control paths to an if or unless-statement.
The syntax for an if-statement with <<BLUE>>elif<<RESET>> is as follows:

<<BLUE>>if <<WHITE>>condition <<BLUE>>then<<RESET>>
    <<CYAN>># body<<RESET>>
<<BLUE>>elif <<WHITE>>condition <<BLUE>>then<<RESET>>
    <<CYAN>># body<<RESET>>
<<BLUE>>fi<<RESET>>

The value of <<WHITE>>condition<<RESET>> will always be fully evaluated.

For the inverse, replace <<BLUE>>elif<<RESET>> with <<BLUE>>elunless<<RESET>>

### else
The <<BLUE>>else<<RESET>> keyword is used to add a default control path to an if or unless-statement in case all previous checks fail.
The syntax for an if-else-statement is as follows:

<<BLUE>>if <<WHITE>>condition <<BLUE>>then<<RESET>>
    <<CYAN>># body<<RESET>>
<<BLUE>>else<<RESET>>
    <<CYAN>># body<<RESET>>
<<BLUE>>fi<<RESET>>

Adding an <<BLUE>>else<<RESET>> to an if-statement makes it an expression returning a single value.

### switch, case, and default
The <<BLUE>>switch<<RESET>> keyword is used to create more efficient control flow for different values.
The syntax is as follows:

<<WHITE>>value <<BLUE>>switch<<RESET>>
    <<BLUE>>case <<GREEN>>1<<RESET>>
        <<CYAN>># body
    <<BLUE>>esac<<RESET>>

    <<BLUE>>default<<RESET>>
        <<CYAN>># body
    <<BLUE>>esac<<RESET>>
<<BLUE>>done<<RESET>>

Switch-expressions can only work on integer values.

### return
The <<BLUE>>return<<RESET>> keyword is used to stop further execution of the current function, and if the function has a return type that is not <<BLUE>>none<<RESET>>,
return the top value on the stack, or the value currently stored in the named return value of the function.

### break
The <<BLUE>>break<<RESET>> keyword is used to immediately stop execution of the innermost loop and jump after it.

### continue
The <<BLUE>>continue<<RESET>> keyword is used to immediately jump to the next iteration of the innermost loop.

### for
The <<BLUE>>for<<RESET>> keyword is used to start the header of a for-loop.

### foreach
### step
### repeat
### goto
### label
### try
### catch

### none
### int
The <<BLUE>>int<<RESET>> type is the generic integer type of Scale. It can store any signed 64-bit integer.

### float
The <<BLUE>>float<<RESET>> type is the generic floating point type of Scale. It can store any 64-bit IEEE754 floating point number.

### int32
The <<BLUE>>int32<<RESET>> type is a specialization of the <<BLUE>>int<<RESET>> type that can only store 32 bits.

### int16
The <<BLUE>>int16<<RESET>> type is a specialization of the <<BLUE>>int<<RESET>> type that can only store 16 bits.

### int8
The <<BLUE>>int8<<RESET>> type is a specialization of the <<BLUE>>int<<RESET>> type that can only store 8 bits.
C Strings are just pointers to a collection of <<BLUE>>int8<<RESET>>s.

### uint
The <<BLUE>>uint<<RESET>> type is the generic unsigned integer type of Scale. It can store any unsigned 64-bit integer.

### uint32
The <<BLUE>>uint32<<RESET>> type is a specialization of the <<BLUE>>uint<<RESET>> type that can only store 32 bits.

### uint16
The <<BLUE>>uint16<<RESET>> type is a specialization of the <<BLUE>>uint<<RESET>> type that can only store 16 bits.

### uint8
The <<BLUE>>uint8<<RESET>> type is a specialization of the <<BLUE>>uint<<RESET>> type that can only store 8 bits.

### int64
Unused.
Same as <<BLUE>>int<<RESET>>.

### uint64
Unused.
Same as <<BLUE>>uint<<RESET>>.

### any
### str
### bool

### nil
### true
### false

### c!
### deprecated!

## Operators
### Store operator
- Using =>
- Using +>
- Using ->
- Using *>
- Using />
- Using &>
- Using |>
- Using ^>
- Using %>

## Frameworks
### Modules
